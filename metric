현재 프로그램의 메트릭 시스템을 분석하고 개선 방안을 제시해 드리겠습니다.

## 현재 수집 중인 메트릭 분석

Read file: src/crosskimp/ob_collector/core/metrics_manager.py

Read file: src/crosskimp/ob_collector/core/metrics_manager.py

Read file: src/crosskimp/ob_collector/orderbook/base_ob_v2.py

Read file: src/crosskimp/ob_collector/orderbook/orderbook/base_ob_v2.py

Read file: src/crosskimp/ob_collector/orderbook/websocket/base_ws_connector.py

Read file: src/crosskimp/ob_collector/orderbook/websocket/base_ws_manager.py

Read file: src/crosskimp/ob_collector/orderbook/websocket/base_ws_connector.py
지금까지 확인한 내용을 바탕으로 현재 프로그램의 메트릭 시스템을 분석하고 개선 방안을 제시하겠습니다.

## 현재 수집 중인 메트릭 분석

현재 프로그램은 다음과 같은 메트릭을 수집하고 있습니다:

### 1. 웹소켓 연결 관련 메트릭
- 연결 상태 (connected, disconnected)
- 연결 시도/성공/실패 횟수
- 재연결 횟수 및 간격
- 연결 지속 시간
- 연결 상태 전이 기록
- 연결 건강도 점수 (0-100)

### 2. 메시지 처리 관련 메트릭
- 메시지 수신 횟수 및 처리율
- 마지막 메시지 수신 시간
- 메시지 처리 시간 (레이턴시)
- 수신/송신 바이트 수

### 3. 오더북 관련 메트릭
- 오더북 메시지 수 및 처리율
- 오더북 업데이트 통계

### 4. 시스템 리소스 메트릭
- CPU 사용률
- 메모리 사용량 및 비율
- 디스크 사용량 및 비율
- 네트워크 송수신 바이트

### 5. 오류 관련 메트릭
- 오류 발생 횟수
- 마지막 오류 시간 및 메시지

## 메트릭 개선 전략적 계획

현재 메트릭 시스템을 개선하기 위한 전략적 계획을 다음과 같이 제안합니다:

### 1. 성능 및 효율성 메트릭 강화

#### 1.1 메시지 처리 성능 메트릭
```python
# 메시지 처리 성능 관련 메트릭 추가
"message_processing_stats": {
    "avg_processing_time_ms": {},  # 평균 처리 시간 (ms)
    "max_processing_time_ms": {},  # 최대 처리 시간 (ms)
    "min_processing_time_ms": {},  # 최소 처리 시간 (ms)
    "processing_time_p95": {},     # 95 퍼센타일 처리 시간 (ms)
    "processing_time_p99": {},     # 99 퍼센타일 처리 시간 (ms)
    "message_size_avg": {},        # 평균 메시지 크기 (bytes)
    "messages_per_second": {},     # 초당 처리 메시지 수
}
```

#### 1.2 메모리 사용량 최적화 메트릭
```python
# 메모리 사용량 관련 메트릭 추가
"memory_usage": {
    "orderbook_memory_usage": {},  # 오더북 메모리 사용량
    "queue_memory_usage": {},      # 큐 메모리 사용량
    "buffer_memory_usage": {},     # 버퍼 메모리 사용량
}
```

### 2. 안정성 및 신뢰성 메트릭 강화

#### 2.1 연결 안정성 메트릭
```python
# 연결 안정성 관련 메트릭 추가
"connection_stability": {
    "connection_uptime_ratio": {},      # 연결 유지 비율 (0-1)
    "avg_connection_duration": {},      # 평균 연결 지속 시간
    "connection_failure_rate": {},      # 연결 실패율
    "reconnect_success_rate": {},       # 재연결 성공률
    "connection_stability_score": {},   # 연결 안정성 점수 (0-100)
}
```

#### 2.2 오류 분석 메트릭
```python
# 오류 분석 관련 메트릭 추가
"error_analysis": {
    "error_types": defaultdict(int),    # 오류 유형별 발생 횟수
    "error_recovery_times": {},         # 오류 복구 시간
    "critical_errors": defaultdict(int), # 심각한 오류 발생 횟수
    "error_patterns": defaultdict(list), # 오류 발생 패턴
}
```

### 3. 비즈니스 가치 메트릭 강화

#### 3.1 오더북 품질 메트릭
```python
# 오더북 품질 관련 메트릭 추가
"orderbook_quality": {
    "spread_stats": {                   # 스프레드 통계
        "avg_spread": {},               # 평균 스프레드
        "min_spread": {},               # 최소 스프레드
        "max_spread": {},               # 최대 스프레드
        "spread_volatility": {},        # 스프레드 변동성
    },
    "depth_stats": {                    # 깊이 통계
        "avg_depth": {},                # 평균 깊이
        "liquidity_at_levels": {},      # 레벨별 유동성
    },
    "update_frequency": {},             # 업데이트 빈도
    "price_impact_stats": {},           # 가격 영향 통계
}
```

#### 3.2 거래 기회 메트릭
```python
# 거래 기회 관련 메트릭 추가
"trading_opportunities": {
    "arbitrage_opportunities": defaultdict(int),  # 차익거래 기회 횟수
    "price_discrepancies": defaultdict(list),     # 가격 불일치 기록
    "significant_price_moves": defaultdict(int),  # 유의미한 가격 변동 횟수
}
```

### 4. 시스템 리소스 모니터링 강화

#### 4.1 상세 시스템 리소스 메트릭
```python
# 시스템 리소스 관련 메트릭 추가
"system_resources": {
    "cpu_usage_per_core": {},           # 코어별 CPU 사용률
    "memory_usage_breakdown": {         # 메모리 사용 내역
        "process_memory": {},           # 프로세스 메모리
        "python_memory": {},            # Python 메모리
        "shared_memory": {},            # 공유 메모리
    },
    "io_stats": {                       # I/O 통계
        "disk_read_bytes": {},          # 디스크 읽기 바이트
        "disk_write_bytes": {},         # 디스크 쓰기 바이트
        "disk_read_count": {},          # 디스크 읽기 횟수
        "disk_write_count": {},         # 디스크 쓰기 횟수
    },
    "network_stats": {                  # 네트워크 통계
        "packets_sent": {},             # 송신 패킷 수
        "packets_recv": {},             # 수신 패킷 수
        "network_errors": {},           # 네트워크 오류 수
    },
    "gc_stats": {                       # 가비지 컬렉션 통계
        "gc_collections": {},           # GC 수행 횟수
        "gc_collected": {},             # GC 수집 객체 수
        "gc_time": {},                  # GC 소요 시간
    }
}
```

#### 4.2 프로세스 성능 메트릭
```python
# 프로세스 성능 관련 메트릭 추가
"process_performance": {
    "thread_count": {},                 # 스레드 수
    "open_file_descriptors": {},        # 열린 파일 디스크립터 수
    "context_switches": {},             # 컨텍스트 스위치 횟수
    "event_loop_lag": {},               # 이벤트 루프 지연 시간
}
```

### 5. 구현 우선순위 및 로드맵

#### 1단계: 핵심 성능 및 안정성 메트릭 (높은 우선순위)
- 메시지 처리 성능 메트릭 (처리 시간 통계)
- 연결 안정성 메트릭 (연결 유지 비율, 안정성 점수)
- 오더북 품질 메트릭 (스프레드 통계)
- 기본 시스템 리소스 모니터링 강화 (CPU, 메모리 세부 정보)

#### 2단계: 비즈니스 가치 및 오류 분석 메트릭 (중간 우선순위)
- 오류 분석 메트릭 (오류 유형별 통계, 복구 시간)
- 거래 기회 메트릭 (차익거래 기회 감지)
- 오더북 깊이 통계 및 유동성 메트릭

#### 3단계: 고급 시스템 모니터링 및 최적화 메트릭 (낮은 우선순위)
- 메모리 사용량 최적화 메트릭
- 프로세스 성능 메트릭
- GC 통계 및 이벤트 루프 지연 시간

### 6. 구현 방법 제안

#### 6.1 메트릭 매니저 확장
`WebsocketMetricsManager` 클래스를 확장하여 새로운 메트릭을 추가하고, 기존 메트릭 수집 로직을 개선합니다.

```python
def initialize_exchange(self, exchange: str) -> None:
    # 기존 초기화 코드...
    
    # 새로운 메트릭 초기화
    self.metrics["message_processing_stats"] = {
        "avg_processing_time_ms": {},
        "max_processing_time_ms": {},
        "min_processing_time_ms": {},
        "processing_time_p95": {},
        "processing_time_p99": {},
        "message_size_avg": {},
        "messages_per_second": {},
    }
    
    self.metrics["connection_stability"] = {
        "connection_uptime_ratio": {},
        "avg_connection_duration": {},
        "connection_failure_rate": {},
        "reconnect_success_rate": {},
        "connection_stability_score": {},
    }
    
    # 초기값 설정
    self.metrics["message_processing_stats"]["avg_processing_time_ms"][exchange] = 0.0
    self.metrics["message_processing_stats"]["max_processing_time_ms"][exchange] = 0.0
    # ... 나머지 초기화
```

#### 6.2 메트릭 수집 로직 개선
메시지 처리 시간, 연결 안정성 등의 메트릭을 계산하는 로직을 추가합니다.

```python
def _calculate_processing_time_stats(self, exchange: str):
    """메시지 처리 시간 통계 계산"""
    processing_times = self.metrics["processing_times"].get(exchange, [])
    if not processing_times:
        return
    
    # 기본 통계 계산
    avg_time = sum(processing_times) / len(processing_times) if processing_times else 0
    max_time = max(processing_times) if processing_times else 0
    min_time = min(processing_times) if processing_times else 0
    
    # 퍼센타일 계산
    sorted_times = sorted(processing_times)
    p95_idx = int(len(sorted_times) * 0.95)
    p99_idx = int(len(sorted_times) * 0.99)
    p95 = sorted_times[p95_idx] if p95_idx < len(sorted_times) else max_time
    p99 = sorted_times[p99_idx] if p99_idx < len(sorted_times) else max_time
    
    # 결과 저장
    self.metrics["message_processing_stats"]["avg_processing_time_ms"][exchange] = avg_time
    self.metrics["message_processing_stats"]["max_processing_time_ms"][exchange] = max_time
    self.metrics["message_processing_stats"]["min_processing_time_ms"][exchange] = min_time
    self.metrics["message_processing_stats"]["processing_time_p95"][exchange] = p95
    self.metrics["message_processing_stats"]["processing_time_p99"][exchange] = p99
```

#### 6.3 시스템 리소스 모니터링 강화
`psutil` 라이브러리를 활용하여 더 상세한 시스템 리소스 정보를 수집합니다.

```python
def get_detailed_system_metrics(self):
    """상세 시스템 메트릭 수집"""
    # CPU 사용률 (전체 및 코어별)
    cpu_percent = psutil.cpu_percent(interval=0.1)
    cpu_percent_per_core = psutil.cpu_percent(interval=0.1, percpu=True)
    
    # 메모리 사용량
    memory = psutil.virtual_memory()
    swap = psutil.swap_memory()
    
    # 디스크 I/O 통계
    disk_io = psutil.disk_io_counters()
    
    # 네트워크 통계
    network = psutil.net_io_counters()
    
    # 프로세스 정보
    process = psutil.Process()
    process_memory = process.memory_info()
    
    # 결과 반환
    return {
        "cpu": {
            "total_percent": cpu_percent,
            "per_core_percent": cpu_percent_per_core,
        },
        "memory": {
            "total": memory.total,
            "available": memory.available,
            "used": memory.used,
            "percent": memory.percent,
            "swap_used": swap.used,
            "swap_percent": swap.percent,
        },
        "disk_io": {
            "read_count": disk_io.read_count,
            "write_count": disk_io.write_count,
            "read_bytes": disk_io.read_bytes,
            "write_bytes": disk_io.write_bytes,
        },
        "network": {
            "bytes_sent": network.bytes_sent,
            "bytes_recv": network.bytes_recv,
            "packets_sent": network.packets_sent,
            "packets_recv": network.packets_recv,
            "errin": network.errin,
            "errout": network.errout,
        },
        "process": {
            "memory_rss": process_memory.rss,
            "memory_vms": process_memory.vms,
            "threads": process.num_threads(),
            "open_files": len(process.open_files()),
            "cpu_percent": process.cpu_percent(interval=0.1),
        }
    }
```

#### 6.4 오더북 품질 메트릭 구현
오더북 품질을 평가하는 메트릭을 추가합니다.

```python
def calculate_orderbook_quality_metrics(self, symbol: str, orderbook: OrderBookV2):
    """오더북 품질 메트릭 계산"""
    # 스프레드 계산
    best_bid = max(orderbook.bids.keys()) if orderbook.bids else 0
    best_ask = min(orderbook.asks.keys()) if orderbook.asks else 0
    spread = best_ask - best_bid if best_bid and best_ask else 0
    spread_percent = (spread / best_bid * 100) if best_bid else 0
    
    # 깊이 계산
    bid_depth = sum(orderbook.bids.values()) if orderbook.bids else 0
    ask_depth = sum(orderbook.asks.values()) if orderbook.asks else 0
    total_depth = bid_depth + ask_depth
    
    # 결과 저장
    exchange = orderbook.exchangename
    if "orderbook_quality" not in self.metrics:
        self.metrics["orderbook_quality"] = {
            "spread_stats": {
                "current_spread": {},
                "current_spread_percent": {},
                "avg_spread": {},
                "min_spread": {},
                "max_spread": {},
            },
            "depth_stats": {
                "bid_depth": {},
                "ask_depth": {},
                "total_depth": {},
            }
        }
    
    # 현재 값 업데이트
    if exchange not in self.metrics["orderbook_quality"]["spread_stats"]["current_spread"]:
        self.metrics["orderbook_quality"]["spread_stats"]["current_spread"][exchange] = {}
        self.metrics["orderbook_quality"]["spread_stats"]["current_spread_percent"][exchange] = {}
        self.metrics["orderbook_quality"]["spread_stats"]["avg_spread"][exchange] = {}
        self.metrics["orderbook_quality"]["spread_stats"]["min_spread"][exchange] = {}
        self.metrics["orderbook_quality"]["spread_stats"]["max_spread"][exchange] = {}
    
    self.metrics["orderbook_quality"]["spread_stats"]["current_spread"][exchange][symbol] = spread
    self.metrics["orderbook_quality"]["spread_stats"]["current_spread_percent"][exchange][symbol] = spread_percent
    
    # 평균, 최소, 최대 스프레드 업데이트
    if symbol not in self.metrics["orderbook_quality"]["spread_stats"]["avg_spread"][exchange]:
        self.metrics["orderbook_quality"]["spread_stats"]["avg_spread"][exchange][symbol] = spread
        self.metrics["orderbook_quality"]["spread_stats"]["min_spread"][exchange][symbol] = spread
        self.metrics["orderbook_quality"]["spread_stats"]["max_spread"][exchange][symbol] = spread
    else:
        # 이동 평균 계산 (가중치 0.05)
        current_avg = self.metrics["orderbook_quality"]["spread_stats"]["avg_spread"][exchange][symbol]
        self.metrics["orderbook_quality"]["spread_stats"]["avg_spread"][exchange][symbol] = current_avg * 0.95 + spread * 0.05
        
        # 최소/최대 업데이트
        self.metrics["orderbook_quality"]["spread_stats"]["min_spread"][exchange][symbol] = min(
            self.metrics["orderbook_quality"]["spread_stats"]["min_spread"][exchange][symbol], spread
        )
        self.metrics["orderbook_quality"]["spread_stats"]["max_spread"][exchange][symbol] = max(
            self.metrics["orderbook_quality"]["spread_stats"]["max_spread"][exchange][symbol], spread
        )
    
    # 깊이 통계 업데이트
    if exchange not in self.metrics["orderbook_quality"]["depth_stats"]["bid_depth"]:
        self.metrics["orderbook_quality"]["depth_stats"]["bid_depth"][exchange] = {}
        self.metrics["orderbook_quality"]["depth_stats"]["ask_depth"][exchange] = {}
        self.metrics["orderbook_quality"]["depth_stats"]["total_depth"][exchange] = {}
    
    self.metrics["orderbook_quality"]["depth_stats"]["bid_depth"][exchange][symbol] = bid_depth
    self.metrics["orderbook_quality"]["depth_stats"]["ask_depth"][exchange][symbol] = ask_depth
    self.metrics["orderbook_quality"]["depth_stats"]["total_depth"][exchange][symbol] = total_depth
```

### 7. 메트릭 시각화 및 알림 개선

#### 7.1 대시보드 개선
수집된 메트릭을 효과적으로 시각화하기 위한 대시보드를 개선합니다.

- 실시간 성능 모니터링 대시보드
- 오더북 품질 대시보드
- 시스템 리소스 대시보드
- 오류 및 안정성 대시보드

#### 7.2 알림 시스템 강화
중요한 메트릭 변화에 대한 알림 시스템을 강화합니다.

```python
def check_alerts(self):
    """메트릭 기반 알림 체크"""
    current_time = time.time()
    
    for exchange in self.metrics["connection_status"]:
        # 연결 상태 알림
        if not self.metrics["connection_status"][exchange]:
            last_alert = self.last_alerts.get(f"{exchange}_disconnected", 0)
            if current_time - last_alert > self.alert_cooldown:
                self.logger.warning(f"[알림] {exchange} 연결 끊김 상태가 지속됨")
                self.last_alerts[f"{exchange}_disconnected"] = current_time
        
        # 메시지 지연 알림
        if self.metrics["connection_status"][exchange]:
            last_message_time = self.metrics["last_message_times"].get(exchange, 0)
            if last_message_time > 0 and current_time - last_message_time > self.message_delay_threshold:
                last_alert = self.last_alerts.get(f"{exchange}_message_delay", 0)
                if current_time - last_alert > self.alert_cooldown:
                    self.logger.warning(
                        f"[알림] {exchange} 메시지 지연 감지: "
                        f"{current_time - last_message_time:.1f}초 동안 메시지 없음"
                    )
                    self.last_alerts[f"{exchange}_message_delay"] = current_time
        
        # 처리 시간 알림
        avg_processing_time = self.metrics["message_processing_stats"]["avg_processing_time_ms"].get(exchange, 0)
        if avg_processing_time > self.processing_time_threshold:
            last_alert = self.last_alerts.get(f"{exchange}_processing_delay", 0)
            if current_time - last_alert > self.alert_cooldown:
                self.logger.warning(
                    f"[알림] {exchange} 처리 시간 임계값 초과: "
                    f"{avg_processing_time:.2f}ms (임계값: {self.processing_time_threshold}ms)"
                )
                self.last_alerts[f"{exchange}_processing_delay"] = current_time
        
        # 시스템 리소스 알림
        if "system_resources" in self.metrics:
            cpu_usage = self.metrics["system_resources"]["cpu"]["total_percent"]
            memory_usage = self.metrics["system_resources"]["memory"]["percent"]
            
            if cpu_usage > self.cpu_threshold:
                last_alert = self.last_alerts.get("high_cpu", 0)
                if current_time - last_alert > self.alert_cooldown:
                    self.logger.warning(
                        f"[알림] 높은 CPU 사용률: {cpu_usage:.1f}% "
                        f"(임계값: {self.cpu_threshold}%)"
                    )
                    self.last_alerts["high_cpu"] = current_time
            
            if memory_usage > self.memory_threshold:
                last_alert = self.last_alerts.get("high_memory", 0)
                if current_time - last_alert > self.alert_cooldown:
                    self.logger.warning(
                        f"[알림] 높은 메모리 사용률: {memory_usage:.1f}% "
                        f"(임계값: {self.memory_threshold}%)"
                    )
                    self.last_alerts["high_memory"] = current_time
```

## 결론

현재 프로그램은 기본적인 웹소켓 연결 및 메시지 처리 메트릭을 잘 수집하고 있지만, 다음과 같은 영역에서 개선이 필요합니다:

1. **성능 및 효율성 메트릭**: 메시지 처리 시간 통계, 메모리 사용량 최적화 메트릭 추가
2. **안정성 및 신뢰성 메트릭**: 연결 안정성 점수, 오류 분석 메트릭 강화
3. **비즈니스 가치 메트릭**: 오더북 품질 메트릭, 거래 기회 감지 메트릭 추가
4. **시스템 리소스 모니터링**: 더 상세한 시스템 리소스 정보 수집
5. **메트릭 시각화 및 알림**: 효과적인 대시보드와 알림 시스템 구축

이러한 개선을 통해 시스템의 성능, 안정성, 비즈니스 가치를 더 잘 모니터링하고 최적화할 수 있을 것입니다. 구현 우선순위에 따라 단계적으로 적용하면 효율적인 메트릭 시스템을 구축할 수 있습니다.
