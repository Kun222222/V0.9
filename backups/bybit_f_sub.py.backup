"""
바이빗 선물 구독 클래스

이 모듈은 바이빗 선물 거래소의 웹소켓 연결을 통해 오더북 데이터를 구독하는 클래스를 제공합니다.
"""

import asyncio
import json
import time
from typing import Dict, List, Optional, Union, Any, Callable

from crosskimp.ob_collector.orderbook.subscription.base_subscription import BaseSubscription
from crosskimp.logger.logger import get_unified_logger, create_raw_logger
from crosskimp.ob_collector.orderbook.connection.bybit_f_cn import BybitFutureWebSocketConnector
from crosskimp.ob_collector.orderbook.validator.validators import BaseOrderBookValidator
from crosskimp.config.paths import LOG_SUBDIRS

# 로거 인스턴스 가져오기
logger = get_unified_logger()

# ============================
# 바이빗 선물 구독 관련 상수
# ============================
# 거래소 정보
EXCHANGE_CODE = "BYBIT_FUTURE"  # 거래소 코드
EXCHANGE_NAME_KR = "[바이빗 선물]"  # 한글 로깅용 이름

# 웹소켓 설정
WS_URL = "wss://stream.bybit.com/v5/public/linear"  # 웹소켓 URL 
MAX_SYMBOLS_PER_SUBSCRIPTION = 10  # 구독당 최대 심볼 수
DEFAULT_DEPTH = 50  # 기본 오더북 깊이

class BybitFutureSubscription(BaseSubscription):
    """
    바이빗 선물 구독 클래스
    
    바이빗 선물 거래소의 웹소켓 연결을 통해 오더북 데이터를 구독하는 클래스입니다.
    
    특징:
    - 메시지 형식: 스냅샷 및 델타 업데이트 지원
    - 웹소켓을 통한 스냅샷 및 델타 업데이트 수신
    """
    def __init__(self, connection: BybitFutureWebSocketConnector):
        """
        바이빗 선물 구독 초기화
        
        Args:
            connection: 바이빗 선물 웹소켓 연결 객체
        """
        super().__init__(connection, EXCHANGE_CODE)
        
        # 오더북 설정
        self.max_symbols_per_subscription = MAX_SYMBOLS_PER_SUBSCRIPTION
        self.depth_level = DEFAULT_DEPTH
        
        # 구독 상태 관리
        self.snapshot_received = set()  # 스냅샷을 받은 심볼 목록
        self.snapshot_pending = set()   # 스냅샷 요청 대기 중인 심볼 목록
        
        # 메시지 처리 통계
        self.message_stats = {
            "total_received": 0,
            "ping_pong": 0,
            "snapshot": 0,
            "delta": 0,
            "processed": 0
        }
        
        # 구독 관리
        self.subscribed_symbols = {}    # 구독 중인 심볼 목록
        self.snapshot_callbacks = {}    # 스냅샷 콜백
        self.delta_callbacks = {}       # 델타 콜백
        self.error_callbacks = {}       # 오류 콜백
        
        # 로깅 설정
        self._setup_raw_logging()
        
        # 메시지 처리 태스크
        self.message_task = None
        
        # 바이빗 오더북 검증기 초기화
        self.validator = BaseOrderBookValidator(EXCHANGE_CODE)
        
        # 각 심볼별 전체 오더북 상태 저장용
        self.orderbooks = {}  # symbol -> {"bids": {...}, "asks": {...}, "timestamp": ..., "sequence": ...}

    def _setup_raw_logging(self):
        """
        원시 메시지 로깅 설정
        """
        self.log_raw_messages = False
        try:
            # 설정에서 로깅 활성화 여부 확인
            if hasattr(self.connection, 'settings'):
                self.log_raw_messages = self.connection.settings.get('logging', {}).get('raw_messages', False)
                
            if self.log_raw_messages:
                self.log_info(f"{EXCHANGE_NAME_KR} 원시 메시지 로깅 활성화")
            else:
                self.log_debug(f"{EXCHANGE_NAME_KR} 원시 메시지 로깅 비활성화")
        except Exception as e:
            self.log_error(f"{EXCHANGE_NAME_KR} 로깅 설정 실패: {str(e)}")
            self.log_raw_messages = False

    async def create_subscribe_message(self, symbol: Union[str, List[str]]) -> Dict:
        """
        구독 메시지 생성
        
        Args:
            symbol: 구독할 심볼 또는 심볼 목록
            
        Returns:
            Dict: 구독 메시지
        """
        # 심볼 리스트로 변환
        symbols = [symbol] if isinstance(symbol, str) else symbol
        
        # 심볼 형식 변환 ({symbol}USDT)
        args = []
        for sym in symbols:
            market = f"{sym}USDT"
            args.append(f"orderbook.{self.depth_level}.{market}")
        
        symbols_str = ", ".join(symbols) if len(symbols) <= 5 else f"{len(symbols)}개 심볼"
        self.log_info(f"{EXCHANGE_NAME_KR} {symbols_str} 구독 메시지 생성")
        
        # 구독 메시지 생성
        return {
            "op": "subscribe",
            "args": args
        }

    async def create_unsubscribe_message(self, symbol: str) -> Dict:
        """
        구독 해제 메시지 생성
        
        Args:
            symbol: 구독 해제할 심볼
            
        Returns:
            Dict: 구독 해제 메시지
        """
        # 심볼 형식 변환 ({symbol}USDT)
        market = f"{symbol}USDT"
        
        # 구독 해제 메시지 생성
        return {
            "op": "unsubscribe",
            "args": [f"orderbook.{self.depth_level}.{market}"]
        }

    def is_snapshot_message(self, message: str) -> bool:
        """
        스냅샷 메시지 여부 확인
        
        Args:
            message: 수신된 웹소켓 메시지
            
        Returns:
            bool: 스냅샷 메시지인 경우 True, 아니면 False
        """
        try:
            data = json.loads(message)
            
            # 구독 응답 또는 핑/퐁 메시지는 스냅샷이 아님
            if data.get("op") == "subscribe" or self.is_pong_message(data):
                return False
                
            # 토픽과 데이터가 있는지 확인
            if "topic" not in data or "data" not in data:
                return False
                
            # 오더북 토픽인지 확인
            topic = data.get("topic", "")
            if "orderbook" not in topic:
                return False
                
            # 메시지 타입이 스냅샷인지 확인
            return data.get("type", "").lower() == "snapshot"
            
        except Exception as e:
            self.log_error(f"{EXCHANGE_NAME_KR} 스냅샷 메시지 확인 실패: {str(e)}")
            return False

    def is_delta_message(self, message: str) -> bool:
        """
        델타 메시지 여부 확인
        
        Args:
            message: 수신된 웹소켓 메시지
            
        Returns:
            bool: 델타 메시지인 경우 True, 아니면 False
        """
        try:
            data = json.loads(message)
            
            # 구독 응답 또는 핑/퐁 메시지는 델타가 아님
            if data.get("op") == "subscribe" or self.is_pong_message(data):
                return False
                
            # 토픽과 데이터가 있는지 확인
            if "topic" not in data or "data" not in data:
                return False
                
            # 오더북 토픽인지 확인
            topic = data.get("topic", "")
            if "orderbook" not in topic:
                return False
                
            # 메시지 타입이 델타인지 확인 (기본값은 델타로 간주)
            return data.get("type", "delta").lower() == "delta"
            
        except Exception as e:
            self.log_error(f"{EXCHANGE_NAME_KR} 델타 메시지 확인 실패: {str(e)}")
            return False

    def is_pong_message(self, data: Dict[str, Any]) -> bool:
        """
        PONG 메시지 여부 확인
        
        Args:
            data: 파싱된 메시지 데이터
            
        Returns:
            bool: PONG 메시지인 경우 True, 아니면 False
        """
        # 바이빗 API 문서에 따른 다양한 PONG 형식 지원
        return (data.get("op") == "pong" or 
                data.get("ret_msg") == "pong" or 
                (isinstance(data.get("args"), list) and "pong" in str(data.get("args"))) or
                (data.get("success") == True and data.get("ret_msg") == "pong"))

    def log_raw_message(self, message: str) -> None:
        """
        원시 메시지 로깅
        
        Args:
            message: 로깅할 원시 메시지
        """
        if not self.log_raw_messages:
            return
            
        try:
            # 메시지 카운터 증가
            if not hasattr(self, '_raw_log_count'):
                self._raw_log_count = 0
            self._raw_log_count += 1
            
            # 주기적으로만 로깅 (100개마다)
            if self._raw_log_count % 100 == 0:
                data = json.loads(message)
                if "topic" in data:
                    topic = data.get("topic", "")
                    parts = topic.split(".")
                    if len(parts) >= 3:
                        symbol = parts[-1].replace("USDT", "")
                        self.log_debug(f"{EXCHANGE_NAME_KR} {symbol} 원시 메시지 (#{self._raw_log_count}): {message[:150]}...")
        except Exception as e:
            # 로깅 중 오류 발생 시 무시 (로깅이 핵심 기능에 영향을 주지 않도록)
            pass

    async def _on_message(self, message: str) -> None:
        """
        메시지 수신 및 처리
        
        Args:
            message: 수신된 웹소켓 메시지
        """
        try:
            # 원시 메시지 로깅
            self.log_raw_message(message)
            
            # 메시지 통계 업데이트
            self.message_stats["total_received"] += 1
            
            # JSON 파싱
            data = json.loads(message)
            
            # 핑/퐁 메시지 처리
            if self.is_pong_message(data):
                self.message_stats["ping_pong"] += 1
                # 연결 객체의 process_message를 호출하여 PONG 타임스탬프 업데이트
                await self.connection.process_message(message)
                return

            # 구독 응답 처리
            if data.get("op") == "subscribe":
                self.log_debug(f"{EXCHANGE_NAME_KR} 구독 응답 수신: {data}")
                return
                
            # 오더북 메시지 처리
            if "topic" in data and "data" in data:
                topic = data.get("topic", "")
                if "orderbook" in topic:
                    parts = topic.split(".")
                    if len(parts) >= 3:
                        symbol = parts[-1].replace("USDT", "")
                        msg_type = data.get("type", "delta").lower()  # "snapshot" or "delta"
                        
                        # 메시지 파싱
                        parsed_data = self._parse_message(message)
                        if parsed_data:
                            # 메시지 통계 업데이트
                            if msg_type == "snapshot":
                                self.message_stats["snapshot"] += 1
                                self.snapshot_received.add(symbol)
                                self.snapshot_pending.discard(symbol)
                            elif msg_type == "delta":
                                self.message_stats["delta"] += 1
                            
                            # 스냅샷 처리
                            if msg_type == "snapshot":
                                # 스냅샷인 경우 오더북 초기화
                                self.orderbooks[symbol] = {
                                    "bids": {float(bid[0]): float(bid[1]) for bid in parsed_data.get("bids", [])},
                                    "asks": {float(ask[0]): float(ask[1]) for ask in parsed_data.get("asks", [])},
                                    "timestamp": parsed_data.get("timestamp"),
                                    "sequence": parsed_data.get("sequence")
                                }
                                self.log_info(f"{EXCHANGE_NAME_KR} {symbol} 스냅샷 수신 및 초기화 완료")
                            
                            # 델타 처리
                            elif msg_type == "delta":
                                # 스냅샷을 받은 후에만 델타 처리
                                if symbol in self.snapshot_received and symbol in self.orderbooks:
                                    # 시퀀스 확인
                                    sequence = parsed_data.get("sequence")
                                    if sequence <= self.orderbooks[symbol]["sequence"]:
                                        self.log_warning(f"{EXCHANGE_NAME_KR} {symbol} 이전 시퀀스의 델타 메시지 수신, 무시 ({sequence} <= {self.orderbooks[symbol]['sequence']})")
                                        return
                                    
                                    # 기존 오더북 가져오기
                                    orderbook = self.orderbooks[symbol]
                                    
                                    # 매수 호가 업데이트
                                    for bid in parsed_data.get("bids", []):
                                        price = float(bid[0])
                                        size = float(bid[1])
                                        if size == 0:
                                            # 수량이 0이면 해당 가격의 호가 삭제
                                            orderbook["bids"].pop(price, None)
                                        else:
                                            # 그렇지 않으면 추가 또는 업데이트
                                            orderbook["bids"][price] = size
                                    
                                    # 매도 호가 업데이트
                                    for ask in parsed_data.get("asks", []):
                                        price = float(ask[0])
                                        size = float(ask[1])
                                        if size == 0:
                                            # 수량이 0이면 해당 가격의 호가 삭제
                                            orderbook["asks"].pop(price, None)
                                        else:
                                            # 그렇지 않으면 추가 또는 업데이트
                                            orderbook["asks"][price] = size
                                    
                                    # 타임스탬프와 시퀀스 업데이트
                                    orderbook["timestamp"] = parsed_data.get("timestamp")
                                    orderbook["sequence"] = sequence
                                else:
                                    self.log_warning(f"{EXCHANGE_NAME_KR} {symbol} 스냅샷 없이 델타 수신, 무시")
                                    return
                            
                            # 정렬된 전체 오더북 구성 (스냅샷과 델타 모두 동일하게 처리)
                            if symbol in self.orderbooks:
                                # 매수(높은 가격 -> 낮은 가격), 매도(낮은 가격 -> 높은 가격)
                                sorted_bids = sorted(self.orderbooks[symbol]["bids"].items(), key=lambda x: x[0], reverse=True)
                                sorted_asks = sorted(self.orderbooks[symbol]["asks"].items(), key=lambda x: x[0])
                                
                                # 배열 형태로 변환 [price, size]
                                bids_array = [[price, size] for price, size in sorted_bids]
                                asks_array = [[price, size] for price, size in sorted_asks]
                                
                                # 완전한 오더북 데이터 구성
                                full_orderbook = {
                                    "bids": bids_array,
                                    "asks": asks_array,
                                    "timestamp": self.orderbooks[symbol]["timestamp"],
                                    "sequence": self.orderbooks[symbol]["sequence"],
                                    "type": "snapshot"  # 항상 완전한 스냅샷 형태로 전달
                                }
                                
                                # 메시지 타입에 따라 적절한 콜백 호출
                                if msg_type == "snapshot":
                                    # 스냅샷 콜백 호출
                                    await self._call_snapshot_callback(symbol, full_orderbook)
                                else:
                                    # 델타 메시지지만 완전한 오더북으로 델타 콜백 호출
                                    await self._call_delta_callback(symbol, full_orderbook)
                                
                                self.message_stats["processed"] += 1
                    
                    # 메시지 처리 통계 로깅 (1000개마다)
                    if self.message_stats["total_received"] % 1000 == 0:
                        self.log_info(
                            f"{EXCHANGE_NAME_KR} 메시지 처리 통계 | 총 수신={self.message_stats['total_received']:,}개, "
                            f"스냅샷={self.message_stats['snapshot']:,}개, "
                            f"델타={self.message_stats['delta']:,}개, "
                            f"처리됨={self.message_stats['processed']:,}개"
                        )
        except json.JSONDecodeError:
            self.log_error(f"{EXCHANGE_NAME_KR} JSON 파싱 실패: {message[:100]}...")
        except Exception as e:
            self.log_error(f"{EXCHANGE_NAME_KR} 메시지 처리 중 오류: {str(e)}")

    def _parse_json_message(self, message: str) -> Optional[Dict]:
        """
        메시지를 JSON으로 파싱하는 공통 헬퍼 메소드
        
        Args:
            message: 원시 메시지 (bytes 또는 str)
            
        Returns:
            Optional[Dict]: 파싱된 JSON 또는 None (파싱 실패시)
        """
        try:
            # 메시지가 bytes인 경우 문자열로 변환
            if isinstance(message, bytes):
                message = message.decode('utf-8')
                
            # 메시지가 문자열인 경우 JSON으로 파싱
            if isinstance(message, str):
                data = json.loads(message)
            else:
                data = message
                
            return data
        except Exception as e:
            self.log_error(f"{EXCHANGE_NAME_KR} JSON 파싱 실패: {str(e)}")
            return None

    def _parse_message(self, message: str) -> Optional[Dict]:
        """
        내부 메시지 파싱 메소드
        
        외부 파서 없이 직접 메시지를 파싱하는 기능
        
        Args:
            message: 수신된 원시 메시지
            
        Returns:
            Optional[Dict]: 파싱된 오더북 데이터 또는 None (파싱 실패시)
        """
        try:
            # 공통 JSON 파싱 메소드 사용
            data = self._parse_json_message(message)
            if data is None:
                return None
                
            # 바이빗 메시지 구조 체크
            if "topic" not in data or "data" not in data:
                return None
            
            # 토픽이 orderbook으로 시작하는지 확인
            topic = data.get("topic", "")
            if not topic.startswith("orderbook."):
                return None
            
            # 메시지 타입 확인 (snapshot 또는 delta)
            data_type = data.get("type", "").lower()
            if data_type not in ["snapshot", "delta"]:
                return None
            
            # 심볼 추출 (orderbook.50.BTCUSDT -> BTC)
            topic_parts = topic.split(".")
            if len(topic_parts) < 3:
                return None
            
            market = topic_parts[2]  # BTCUSDT
            if not market.endswith("USDT"):
                return None
            
            symbol = market[:-4]  # BTCUSDT -> BTC
            
            # 데이터 추출
            orderbook_data = data.get("data", {})
            
            # 타임스탬프 추출
            timestamp = orderbook_data.get("ts")
            
            # 시퀀스 추출 (u: updateId)
            sequence = orderbook_data.get("u", 0)
            
            # 매수 호가 추출
            bids_data = orderbook_data.get("b", [])
            bids = [[float(price), float(size)] for price, size in bids_data]
            
            # 매도 호가 추출
            asks_data = orderbook_data.get("a", [])
            asks = [[float(price), float(size)] for price, size in asks_data]
            
            # 파싱된 데이터 반환 (현물 형식과 맞추기)
            return {
                "symbol": symbol,
                "timestamp": timestamp,
                "sequence": sequence,
                "bids": bids,
                "asks": asks,
                "type": data_type  # snapshot 또는 delta
            }
            
        except Exception as e:
            self.log_error(f"{EXCHANGE_NAME_KR} 메시지 파싱 실패: {str(e)}")
            return None

    def _validate_timestamp(self, symbol: str, timestamp: int) -> bool:
        """
        타임스탬프 유효성 검사
        
        Args:
            symbol: 심볼
            timestamp: 검증할 타임스탬프
            
        Returns:
            bool: 유효한 타임스탬프인 경우 True, 아니면 False
        """
        # 현재 시간과 비교하여 미래 타임스탬프인지 확인
        current_time = int(time.time() * 1000)
        if timestamp > current_time + 5000:  # 5초 이상 미래의 타임스탬프는 의심스러움
            self.log_warning(f"{EXCHANGE_NAME_KR} {symbol} 타임스탬프 유효성 검사 실패: 미래 타임스탬프 ({timestamp} > {current_time})")
            return False
            
        # 과거 타임스탬프인지 확인 (30초 이상 과거면 의심스러움)
        if current_time - timestamp > 30000:
            self.log_warning(f"{EXCHANGE_NAME_KR} {symbol} 타임스탬프 유효성 검사 실패: 오래된 타임스탬프 ({current_time - timestamp}ms 지남)")
            return False
            
        return True

    async def subscribe(self, symbol, on_snapshot=None, on_delta=None, on_error=None):
        """
        오더북 구독 시작
        
        Args:
            symbol: 구독할 심볼
            on_snapshot: 스냅샷 콜백 함수
            on_delta: 델타 콜백 함수
            on_error: 오류 콜백 함수
            
        Returns:
            bool: 구독 성공 여부
        """
        try:
            # 콜백 등록
            self._register_callbacks(symbol, on_snapshot, on_delta, on_error)
            
            # 심볼 리스트로 변환
            if isinstance(symbol, list):
                symbols = symbol
            else:
                symbols = [symbol]
                
            # 심볼별 처리
            success_count = 0
            for sym in symbols:
                try:
                    # 구독 메시지 생성 및 전송 준비
                    subscribe_msg = await self.create_subscribe_message(sym)
                    
                    # 메시지 전송 (연결이 없거나 연결되지 않은 경우 연결 시도)
                    if not self.connection.is_connected:
                        self.log_info(f"{EXCHANGE_NAME_KR} {sym} 구독 전 연결 시도")
                        await self.connection.connect()
                        
                    # 연결 확인 후 구독 메시지 전송
                    if self.connection.is_connected:
                        await self.connection.send_message(json.dumps(subscribe_msg))
                        self.log_info(f"{EXCHANGE_NAME_KR} {sym} 구독 메시지 전송 완료")
                        
                        # 스냅샷 요청 예약
                        self.snapshot_pending.add(sym)
                        asyncio.create_task(self._request_snapshot_task(sym))
                        
                        success_count += 1
                    else:
                        self.log_error(f"{EXCHANGE_NAME_KR} {sym} 구독 실패: 연결되지 않음")
                        if on_error:
                            await on_error(sym, "웹소켓 연결 실패")
                    
                except Exception as e:
                    self.log_error(f"{EXCHANGE_NAME_KR} {sym} 구독 중 예외 발생: {str(e)}")
                    if on_error:
                        await on_error(sym, f"구독 오류: {str(e)}")
                
            # 메시지 처리 루프 시작 (이미 실행 중인 경우 생략)
            if success_count > 0 and (self.message_task is None or self.message_task.done()):
                self.message_task = asyncio.create_task(self.message_loop())
                
            return success_count > 0
            
        except Exception as e:
            self.log_error(f"{EXCHANGE_NAME_KR} 구독 처리 중 예외 발생: {str(e)}")
            if on_error:
                await on_error(symbol if isinstance(symbol, str) else "multiple", f"구독 처리 오류: {str(e)}")
            return False

    async def _request_snapshot_task(self, symbol: str, retry_count: int = 3) -> None:
        """
        스냅샷 요청 태스크 (웹소켓 방식)
        
        바이빗 선물은 웹소켓을 통해 스냅샷을 수신합니다.
        구독 후 스냅샷 메시지가 자동으로 수신되기를 기다립니다.
        
        Args:
            symbol: 스냅샷을 요청할 심볼
            retry_count: 재시도 횟수 (웹소켓 스냅샷에서는 사용되지 않음)
        """
        # 짧은 대기 후 시작 (구독 요청이 처리될 시간 부여)
        await asyncio.sleep(0.5)
        
        # 이미 스냅샷을 받은 경우 생략
        if symbol in self.snapshot_received:
            self.log_debug(f"{EXCHANGE_NAME_KR} {symbol} 이미 스냅샷 수신됨 (웹소켓)")
            return
        
        # 웹소켓 스냅샷은 구독 시 자동으로 전송되므로, 일정 시간 기다리고 체크
        timeout = 10  # 10초 타임아웃
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            # 스냅샷을 수신했는지 확인
            if symbol in self.snapshot_received:
                self.log_info(f"{EXCHANGE_NAME_KR} {symbol} 웹소켓 스냅샷 수신 완료")
                return
                
            # 잠시 대기 후 다시 확인
            await asyncio.sleep(0.5)
        
        # 타임아웃 발생 - 스냅샷을 수신하지 못함
        self.log_warning(f"{EXCHANGE_NAME_KR} {symbol} 웹소켓 스냅샷 수신 타임아웃")
        
        # 오류 콜백 호출
        callback = self._get_error_callback(symbol)
        if callback:
            try:
                await callback(symbol, "웹소켓 스냅샷 수신 타임아웃")
            except Exception as e:
                self.log_error(f"{EXCHANGE_NAME_KR} {symbol} 오류 콜백 호출 실패: {str(e)}")

    def _is_connected(self) -> bool:
        """
        연결 상태 확인
        
        Returns:
            bool: 연결된 상태인 경우 True, 아니면 False
        """
        return self.connection.is_connected if self.connection else False

    async def _cancel_tasks(self) -> None:
        """백그라운드 태스크 취소"""
        if self.message_task and not self.message_task.done():
            self.message_task.cancel()
            try:
                await self.message_task
            except asyncio.CancelledError:
                pass
            except Exception as e:
                self.log_error(f"{EXCHANGE_NAME_KR} 메시지 태스크 취소 중 오류: {str(e)}")

    async def _cancel_message_loop(self) -> None:
        """메시지 루프 취소"""
        await self._cancel_tasks()
        self.message_task = None

    async def _unsubscribe_symbol(self, symbol: str) -> bool:
        """
        개별 심볼 구독 해제
        
        Args:
            symbol: 구독 해제할 심볼
            
        Returns:
            bool: 구독 해제 성공 여부
        """
        if not self._is_connected():
            self.log_error(f"{EXCHANGE_NAME_KR} {symbol} 구독 해제 실패: 연결되지 않음")
            return False
            
        try:
            # 구독 해제 메시지 생성 및 전송
            unsubscribe_msg = await self.create_unsubscribe_message(symbol)
            await self.connection.send_message(json.dumps(unsubscribe_msg))
            
            # 구독 정리
            self._cleanup_subscription(symbol)
            
            # 스냅샷 관련 상태 정리
            self.snapshot_received.discard(symbol)
            self.snapshot_pending.discard(symbol)
            
            # 검증기에서 심볼 데이터 정리
            self.validator.clear_symbol(symbol)
            
            self.log_info(f"{EXCHANGE_NAME_KR} {symbol} 구독 해제 완료")
            return True
            
        except Exception as e:
            self.log_error(f"{EXCHANGE_NAME_KR} {symbol} 구독 해제 중 오류: {str(e)}")
            return False

    async def unsubscribe(self, symbol: Optional[str] = None) -> bool:
        """
        구독 해제
        
        Args:
            symbol: 구독 해제할 심볼 (None인 경우 모든 심볼 구독 해제)
            
        Returns:
            bool: 구독 해제 성공 여부
        """
        try:
            # 개별 심볼 구독 해제
            if symbol:
                return await self._unsubscribe_symbol(symbol)
                
            # 모든 심볼 구독 해제
            success = True
            symbols = list(self._get_all_subscribed_symbols())
            
            self.log_info(f"{EXCHANGE_NAME_KR} 모든 심볼 구독 해제 ({len(symbols)}개)")
            
            # 각 심볼별 구독 해제
            for sym in symbols:
                result = await self._unsubscribe_symbol(sym)
                if not result:
                    success = False
                    
            # 메시지 루프 취소
            await self._cancel_message_loop()
            
            # 검증기 데이터 정리
            self.validator.clear_all()
            
            return success
            
        except Exception as e:
            self.log_error(f"{EXCHANGE_NAME_KR} 구독 해제 중 오류: {str(e)}")
            return False

    def _extract_symbol_from_message(self, message: str) -> Optional[str]:
        """
        메시지에서 심볼 추출
        
        Args:
            message: 수신된 메시지
            
        Returns:
            Optional[str]: 추출된 심볼 또는 None
        """
        try:
            data = json.loads(message)
            
            # 구독 응답 또는 핑/퐁 메시지는 심볼이 없음
            if data.get("op") == "subscribe" or data.get("op") == "pong" or (data.get("ret_msg") == "pong" and data.get("op") == "ping"):
                return None
                
            # 토픽에서 심볼 추출
            if "topic" in data:
                topic = data.get("topic", "")
                if "orderbook" in topic:
                    parts = topic.split(".")
                    if len(parts) >= 3:
                        # BTCUSDT -> BTC 형태로 변환
                        symbol = parts[-1].replace("USDT", "")
                        return symbol
            
            return None
            
        except Exception as e:
            self.log_error(f"{EXCHANGE_NAME_KR} 심볼 추출 실패: {str(e)}")
            return None
            
    def _parse_snapshot_message(self, message: str) -> Optional[Dict]:
        """
        스냅샷 메시지 파싱
        
        Args:
            message: 수신된 스냅샷 메시지
            
        Returns:
            Optional[Dict]: 파싱된 스냅샷 데이터 또는 None
        """
        try:
            data = json.loads(message)
            
            # 데이터가 있는지 확인
            if "data" not in data:
                return None
                
            msg_data = data["data"]
            
            # 토픽에서 심볼 추출
            symbol = self._extract_symbol_from_message(message)
            if not symbol:
                return None
                
            # 타임스탬프 추출
            timestamp = msg_data.get("ts", int(time.time() * 1000))
            
            # 호가 데이터 추출
            bids = [[float(item[0]), float(item[1])] for item in msg_data.get("b", [])
            asks = [[float(item[0]), float(item[1])] for item in msg_data.get("a", [])]
            
            # 파싱된 데이터 반환
            return {
                "symbol": symbol,
                "timestamp": timestamp,
                "bids": bids,
                "asks": asks
            }
            
        except Exception as e:
            self.log_error(f"{EXCHANGE_NAME_KR} 스냅샷 메시지 파싱 실패: {str(e)}")
            return None
            
    def _parse_delta_message(self, message: str) -> Optional[Dict]:
        """
        델타 메시지 파싱
        
        Args:
            message: 수신된 델타 메시지
            
        Returns:
            Optional[Dict]: 파싱된 델타 데이터 또는 None
        """
        try:
            data = json.loads(message)
            
            # 데이터가 있는지 확인
            if "data" not in data:
                return None
                
            msg_data = data["data"]
            
            # 토픽에서 심볼 추출
            symbol = self._extract_symbol_from_message(message)
            if not symbol:
                return None
                
            # 타임스탬프 추출
            timestamp = msg_data.get("ts", int(time.time() * 1000))
            
            # 호가 데이터 추출
            bids = [[float(item[0]), float(item[1])] for item in msg_data.get("b", [])
            asks = [[float(item[0]), float(item[1])] for item in msg_data.get("a", [])
            
            # 파싱된 데이터 반환
            return {
                "symbol": symbol,
                "timestamp": timestamp,
                "bids": bids,
                "asks": asks
            }
            
        except Exception as e:
            self.log_error(f"{EXCHANGE_NAME_KR} 델타 메시지 파싱 실패: {str(e)}")
            return None

    def _register_callbacks(self, symbol, on_snapshot=None, on_delta=None, on_error=None):
        """
        심볼에 대한 콜백 함수들을 등록합니다.
        
        Args:
            symbol: 등록할 심볼 또는 심볼 리스트
            on_snapshot: 스냅샷 콜백 함수
            on_delta: 델타 콜백 함수
            on_error: 오류 콜백 함수
        """
        # 심볼 리스트로 변환
        if isinstance(symbol, list):
            symbols = symbol
        else:
            symbols = [symbol]
            
        # 각 심볼별 콜백 등록
        for sym in symbols:
            if on_snapshot:
                self.snapshot_callbacks[sym] = on_snapshot
            if on_delta:
                self.delta_callbacks[sym] = on_delta
            if on_error:
                self.error_callbacks[sym] = on_error
                
            # 구독 목록에 추가
            self.subscribed_symbols[sym] = True
            
    def _get_snapshot_callback(self, symbol: str) -> Optional[Callable]:
        """
        심볼에 대한 스냅샷 콜백 함수 반환
        
        Args:
            symbol: 심볼
            
        Returns:
            Optional[Callable]: 스냅샷 콜백 함수 또는 None
        """
        return self.snapshot_callbacks.get(symbol)
        
    def _get_delta_callback(self, symbol: str) -> Optional[Callable]:
        """
        심볼에 대한 델타 콜백 함수 반환
        
        Args:
            symbol: 심볼
            
        Returns:
            Optional[Callable]: 델타 콜백 함수 또는 None
        """
        return self.delta_callbacks.get(symbol)
        
    def _get_error_callback(self, symbol: str) -> Optional[Callable]:
        """
        심볼에 대한 오류 콜백 함수 반환
        
        Args:
            symbol: 심볼
            
        Returns:
            Optional[Callable]: 오류 콜백 함수 또는 None
        """
        return self.error_callbacks.get(symbol)
        
    def _get_all_subscribed_symbols(self) -> List[str]:
        """
        구독 중인 모든 심볼 목록 반환
        
        Returns:
            List[str]: 구독 중인 모든 심볼 목록
        """
        return list(self.subscribed_symbols.keys())

    async def _call_snapshot_callback(self, symbol: str, data: Dict) -> None:
        """
        스냅샷 콜백 메서드
        
        Args:
            symbol: 심볼
            data: 스냅샷 데이터
        """
        try:
            # 콜백 함수 가져오기
            callback = self._get_snapshot_callback(symbol)
            if callback:
                # 콜백 호출 (오더북 검증기에서 처리된 완전한 오더북 데이터 사용)
                await callback(symbol, data)
        except Exception as e:
            self.log_error(f"{EXCHANGE_NAME_KR} {symbol} 스냅샷 콜백 호출 실패: {str(e)}")

    async def _call_delta_callback(self, symbol: str, data: Dict) -> None:
        """
        델타 콜백 메서드
        
        Args:
            symbol: 심볼
            data: 델타 데이터 (현물 방식에서는 완전한 오더북 형태)
        """
        try:
            # 콜백 함수 가져오기
            callback = self._get_delta_callback(symbol)
            if callback:
                # 콜백 호출 (오더북 검증기에서 처리된 완전한 오더북 데이터 사용)
                await callback(symbol, data)
        except Exception as e:
            self.log_error(f"{EXCHANGE_NAME_KR} {symbol} 델타 콜백 호출 실패: {str(e)}") 