<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>메트릭 모니터링</title>
    <style>
        body {
            font-family: 'Noto Sans KR', Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(380px, 1fr));
            gap: 20px;
        }
        .metrics-card {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
            transition: transform 0.2s;
        }
        .metrics-card:hover {
            transform: translateY(-5px);
        }
        .metrics-card h2 {
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
            display: flex;
            justify-content: space-between;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-active {
            background-color: #4caf50;
        }
        .status-inactive {
            background-color: #f44336;
        }
        .metric-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }
        .metric-label {
            font-weight: bold;
            color: #555;
        }
        .metric-value {
            font-family: 'Courier New', monospace;
        }
        .errors-section {
            margin-top: 15px;
            background-color: #fff9f9;
            border-radius: 5px;
            padding: 10px;
        }
        .errors-section h3 {
            margin-top: 0;
            color: #d32f2f;
            font-size: 16px;
        }
        .error-item {
            font-size: 14px;
            margin-bottom: 5px;
            color: #555;
        }
        @media (max-width: 768px) {
            .metrics-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>크로스 김프 메트릭 모니터링</h1>
        <div id="metrics-container" class="metrics-grid">
            <div class="loading">데이터 로딩 중...</div>
        </div>
    </div>

    <script>
        // WebSocket 연결
        const socket = new WebSocket(`ws://${window.location.host}/ws`);
        const metricsContainer = document.getElementById('metrics-container');

        socket.onmessage = (event) => {
            const data = JSON.parse(event.data);
            updateMetricsDisplay(data);
        };

        socket.onclose = () => {
            console.log('WebSocket 연결이 종료되었습니다.');
            metricsContainer.innerHTML = '<div class="error">서버 연결이 종료되었습니다. 페이지를 새로고침하세요.</div>';
        };

        socket.onerror = (error) => {
            console.error('WebSocket 오류:', error);
            metricsContainer.innerHTML = '<div class="error">서버 연결 중 오류가 발생했습니다.</div>';
        };

        function updateMetricsDisplay(data) {
            metricsContainer.innerHTML = '';
            
            for (const [exchange, metrics] of Object.entries(data)) {
                const isActive = metrics.last_message_time && 
                                 (Date.now() / 1000 - metrics.last_message_time) < 10;
                
                const card = document.createElement('div');
                card.className = 'metrics-card';
                
                // 헤더 생성
                const header = document.createElement('h2');
                const statusIndicator = document.createElement('span');
                statusIndicator.className = `status-indicator ${isActive ? 'status-active' : 'status-inactive'}`;
                header.appendChild(statusIndicator);
                header.appendChild(document.createTextNode(exchange));
                card.appendChild(header);
                
                // 메트릭 추가
                addMetricRow(card, '총 메시지 수', metrics.message_count?.toLocaleString() || '0');
                addMetricRow(card, '메시지 속도', `${metrics.message_rate?.toFixed(2) || '0'} 건/초`);
                addMetricRow(card, '평균 메시지 속도', `${metrics.avg_rate?.toFixed(2) || '0'} 건/초`);
                addMetricRow(card, '처리 시간', `${metrics.processing_time?.toFixed(4) || '0'} 초`);
                
                // 마지막 메시지 시간 추가
                if (metrics.last_message_time) {
                    const date = new Date(metrics.last_message_time * 1000);
                    addMetricRow(card, '마지막 수신', date.toLocaleTimeString());
                }
                
                // 에러 섹션 추가
                if (metrics.errors && metrics.errors.length > 0) {
                    const errorsSection = document.createElement('div');
                    errorsSection.className = 'errors-section';
                    
                    const errorsHeader = document.createElement('h3');
                    errorsHeader.textContent = '최근 오류';
                    errorsSection.appendChild(errorsHeader);
                    
                    metrics.errors.forEach(error => {
                        const errorItem = document.createElement('div');
                        errorItem.className = 'error-item';
                        errorItem.textContent = `${new Date(error.timestamp * 1000).toLocaleTimeString()}: ${error.message}`;
                        errorsSection.appendChild(errorItem);
                    });
                    
                    card.appendChild(errorsSection);
                }
                
                metricsContainer.appendChild(card);
            }
        }

        function addMetricRow(parent, label, value) {
            const row = document.createElement('div');
            row.className = 'metric-row';
            
            const labelEl = document.createElement('div');
            labelEl.className = 'metric-label';
            labelEl.textContent = label;
            
            const valueEl = document.createElement('div');
            valueEl.className = 'metric-value';
            valueEl.textContent = value;
            
            row.appendChild(labelEl);
            row.appendChild(valueEl);
            parent.appendChild(row);
        }
        
        function formatBytes(bytes, decimals = 2) {
            if (bytes === 0) return '0 Bytes';
            
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }
    </script>
</body>
</html>
        