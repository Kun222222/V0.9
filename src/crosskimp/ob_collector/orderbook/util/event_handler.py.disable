"""
ê±°ë˜ì†Œ ì´ë²¤íŠ¸ ì²˜ë¦¬ ë° í†µí•© ê´€ë¦¬ ëª¨ë“ˆ

ì´ ëª¨ë“ˆì€ ê±°ë˜ì†Œ ì´ë²¤íŠ¸ ì²˜ë¦¬ ë° í†µí•© ê´€ë¦¬ í´ë˜ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
ê° ê±°ë˜ì†Œë³„ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ì—¬ ê±°ë˜ì†Œ ì´ë²¤íŠ¸ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.
"""

import time
import logging
import asyncio
import inspect
from typing import Dict, List, Any, Optional, Set, Tuple

from crosskimp.logger.logger import get_unified_logger
from crosskimp.config.constants_v3 import EXCHANGE_NAMES_KR
from crosskimp.ob_collector.eventbus.types import EventTypes
from crosskimp.ob_collector.eventbus.handler import get_orderbook_event_bus
from crosskimp.system_manager.metric_manager import get_metric_manager, MetricKeys
from crosskimp.system_manager.notification_manager import get_notification_manager, NotificationType

# ë¡œê±° ì„¤ì •
logger = get_unified_logger()

class LoggingMixin:
    """
    ë¡œê¹… ë¯¹ìŠ¤ì¸ í´ë˜ìŠ¤
    
    ë¡œê¹… ê¸°ëŠ¥ì„ ì œê³µí•˜ëŠ” ë¯¹ìŠ¤ì¸ í´ë˜ìŠ¤ì…ë‹ˆë‹¤.
    ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ë° ê¸°íƒ€ í´ë˜ìŠ¤ì—ì„œ ë¡œê¹… ê¸°ëŠ¥ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.
    """
    
    def setup_logger(self, exchange_code: str):
        """
        ë¡œê±° ì„¤ì •
        
        Args:
            exchange_code: ê±°ë˜ì†Œ ì½”ë“œ
        """
        self.exchange_code = exchange_code.lower()
        self.exchange_name_kr = EXCHANGE_NAMES_KR.get(self.exchange_code, f"[{self.exchange_code}]")
        self._logger = logger  # ì „ì—­ ë¡œê±° ì°¸ì¡°
    
    def log_error(self, message: str, exc_info=False) -> None:
        """ì˜¤ë¥˜ ë¡œê¹… (ê±°ë˜ì†Œ ì´ë¦„ í¬í•¨)"""
        # ì¬ê·€ ë°©ì§€ë¥¼ ìœ„í•œ ì—¬ë¶€ í™•ì¸
        is_wrapper = False
        for frame_info in inspect.stack()[1:3]:  # í˜¸ì¶œ ìŠ¤íƒ í™•ì¸
            if frame_info.function == 'log_error' and 'base_subscription.py' in frame_info.filename:
                is_wrapper = True
                break
        
        # ë˜í•‘ëœ í˜¸ì¶œì´ë©´ ë©”ì‹œì§€ë§Œ ê¸°ë¡
        if is_wrapper:
            self._logger.error(message, exc_info=exc_info)
        # ì¼ë°˜ í˜¸ì¶œì´ë©´ ê±°ë˜ì†Œ ì´ë¦„ í¬í•¨í•´ì„œ ê¸°ë¡
        else:
            if not hasattr(self, 'exchange_name_kr'):
                self._logger.error(message, exc_info=exc_info)
            else:
                self._logger.error(f"{self.exchange_name_kr} {message}", exc_info=exc_info)
    
    def log_warning(self, message: str, exc_info=False) -> None:
        """ê²½ê³  ë¡œê¹… (ê±°ë˜ì†Œ ì´ë¦„ í¬í•¨)"""
        # ì¬ê·€ ë°©ì§€ë¥¼ ìœ„í•œ ì—¬ë¶€ í™•ì¸
        is_wrapper = False
        for frame_info in inspect.stack()[1:3]:  # í˜¸ì¶œ ìŠ¤íƒ í™•ì¸
            if frame_info.function == 'log_warning' and 'base_subscription.py' in frame_info.filename:
                is_wrapper = True
                break
        
        # ë˜í•‘ëœ í˜¸ì¶œì´ë©´ ë©”ì‹œì§€ë§Œ ê¸°ë¡
        if is_wrapper:
            self._logger.warning(message, exc_info=exc_info)
        # ì¼ë°˜ í˜¸ì¶œì´ë©´ ê±°ë˜ì†Œ ì´ë¦„ í¬í•¨í•´ì„œ ê¸°ë¡
        else:
            if not hasattr(self, 'exchange_name_kr'):
                self._logger.warning(message, exc_info=exc_info)
            else:
                self._logger.warning(f"{self.exchange_name_kr} {message}", exc_info=exc_info)
    
    def log_info(self, message: str, exc_info=False) -> None:
        """ì •ë³´ ë¡œê¹… (ê±°ë˜ì†Œ ì´ë¦„ í¬í•¨)"""
        # ì¬ê·€ ë°©ì§€ë¥¼ ìœ„í•œ ì—¬ë¶€ í™•ì¸
        is_wrapper = False
        for frame_info in inspect.stack()[1:3]:  # í˜¸ì¶œ ìŠ¤íƒ í™•ì¸
            if frame_info.function == 'log_info' and 'base_subscription.py' in frame_info.filename:
                is_wrapper = True
                break
        
        # ë˜í•‘ëœ í˜¸ì¶œì´ë©´ ë©”ì‹œì§€ë§Œ ê¸°ë¡
        if is_wrapper:
            self._logger.info(message, exc_info=exc_info)
        # ì¼ë°˜ í˜¸ì¶œì´ë©´ ê±°ë˜ì†Œ ì´ë¦„ í¬í•¨í•´ì„œ ê¸°ë¡
        else:
            if not hasattr(self, 'exchange_name_kr'):
                self._logger.info(message, exc_info=exc_info)
            else:
                self._logger.info(f"{self.exchange_name_kr} {message}", exc_info=exc_info)
    
    def log_debug(self, message: str, exc_info=False) -> None:
        """ë””ë²„ê·¸ ë¡œê¹… (ê±°ë˜ì†Œ ì´ë¦„ í¬í•¨)"""
        # ì¬ê·€ ë°©ì§€ë¥¼ ìœ„í•œ ì—¬ë¶€ í™•ì¸
        is_wrapper = False
        for frame_info in inspect.stack()[1:3]:  # í˜¸ì¶œ ìŠ¤íƒ í™•ì¸
            if frame_info.function == 'log_debug' and 'base_subscription.py' in frame_info.filename:
                is_wrapper = True
                break
        
        # ë˜í•‘ëœ í˜¸ì¶œì´ë©´ ë©”ì‹œì§€ë§Œ ê¸°ë¡
        if is_wrapper:
            self._logger.debug(message, exc_info=exc_info)
        # ì¼ë°˜ í˜¸ì¶œì´ë©´ ê±°ë˜ì†Œ ì´ë¦„ í¬í•¨í•´ì„œ ê¸°ë¡
        else:
            if not hasattr(self, 'exchange_name_kr'):
                self._logger.debug(message, exc_info=exc_info)
            else:
                self._logger.debug(f"{self.exchange_name_kr} {message}", exc_info=exc_info)

    def log_critical(self, message: str, exc_info=False) -> None:
        """ì‹¬ê°í•œ ì˜¤ë¥˜ ë¡œê¹… (ê±°ë˜ì†Œ ì´ë¦„ í¬í•¨)"""
        if not hasattr(self, 'exchange_name_kr'):
            self._logger.critical(message, exc_info=exc_info)
        else:
            self._logger.critical(f"{self.exchange_name_kr} {message}", exc_info=exc_info)

class EventHandler(LoggingMixin):
    """
    ê±°ë˜ì†Œ ì´ë²¤íŠ¸ ì²˜ë¦¬ ë° í†µí•© ê´€ë¦¬ í´ë˜ìŠ¤
    
    ê±°ë˜ì†Œ ì´ë²¤íŠ¸ ì²˜ë¦¬ì™€ ì´ë²¤íŠ¸ í†µí•©ì„ ë‹´ë‹¹í•©ë‹ˆë‹¤.
    ë¡œê¹…, ì´ë²¤íŠ¸ ë°œí–‰, ì•Œë¦¼ ì „ì†¡ ë“±ì˜ ì—­í• ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
    """
    
    _instances = {}  # ê±°ë˜ì†Œ ì½”ë“œ -> í•¸ë“¤ëŸ¬ ì¸ìŠ¤í„´ìŠ¤
    
    @classmethod
    def get_instance(cls, exchange_code: str, settings: Dict[str, Any]) -> 'EventHandler':
        """
        ê±°ë˜ì†Œë³„ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì¸ìŠ¤í„´ìŠ¤ ë°˜í™˜ (ì‹±ê¸€í†¤ íŒ¨í„´)
        
        Args:
            exchange_code: ê±°ë˜ì†Œ ì½”ë“œ
            settings: ì„¤ì • ì •ë³´
            
        Returns:
            EventHandler: ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì¸ìŠ¤í„´ìŠ¤
        """
        exchange_code = exchange_code.lower()  # ì •ê·œí™”
        
        if exchange_code not in cls._instances:
            cls._instances[exchange_code] = EventHandler(exchange_code, settings)
            
        return cls._instances[exchange_code]
    
    def __init__(self, exchange_code: str, settings: Dict[str, Any]):
        """
        ì´ˆê¸°í™”
        
        Args:
            exchange_code: ê±°ë˜ì†Œ ì½”ë“œ (ì˜ˆ: 'upbit', 'bithumb', 'bybit' ë“±)
            settings: ì„¤ì • ì •ë³´
        """
        # ë¡œê±° ì„¤ì • (ë¯¹ìŠ¤ì¸ ë©”ì„œë“œ ì‚¬ìš©)
        self.setup_logger(exchange_code.lower())
        
        self.settings = settings
        self.exchange_code = exchange_code.lower()
        
        # ê±°ë˜ì†Œ ì´ë¦„ (í•œê¸€) ì„¤ì •
        self.exchange_name_kr = EXCHANGE_NAMES_KR.get(self.exchange_code, f"[{self.exchange_code}]")
        
        # ì´ë²¤íŠ¸ ë²„ìŠ¤ ê°€ì ¸ì˜¤ê¸°
        self.event_bus = get_orderbook_event_bus()
        
        # ì—°ê²° ìƒíƒœ ì €ì¥ì†Œ (ìš´ì˜ ë¡œì§ìš©)
        self.connection_status = "disconnected"
        
        # êµ¬ë… ìƒíƒœ ì €ì¥ì†Œ (ìš´ì˜ ë¡œì§ìš©)
        self.subscriptions = {
            "symbols": [],
            "status": "unsubscribed"
        }
        
        # ì•Œë¦¼ ì œí•œ ê´€ë ¨ ë³€ìˆ˜
        self._last_notification_time = {}  # ì´ë²¤íŠ¸ íƒ€ì…ë³„ ë§ˆì§€ë§‰ ì•Œë¦¼ ì‹œê°„
        self._notification_cooldown = 60  # ì•Œë¦¼ ì¿¨ë‹¤ìš´ (ì´ˆ)
    
        # ì¢…ë£Œ ìƒíƒœ í”Œë˜ê·¸
        self._is_shutting_down = False
        
        # ë©”íŠ¸ë¦­ ê´€ë¦¬ì ì°¸ì¡°
        self.metric_manager = get_metric_manager()
        
        # ì´ˆê¸°í™” ì™„ë£Œ ë¡œê·¸
        self.log_info(f"{self.exchange_name_kr} ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì´ˆê¸°í™” ì™„ë£Œ")

    async def handle_error(self, error_type: str, message: str, severity: str = "error", **kwargs) -> None:
        """
        ì˜¤ë¥˜ ì´ë²¤íŠ¸ ì²˜ë¦¬
        
        Args:
            error_type: ì˜¤ë¥˜ ìœ í˜• (ì˜ˆ: 'connection_error', 'timeout', 'auth_error' ë“±)
            message: ì˜¤ë¥˜ ë©”ì‹œì§€
            severity: ì‹¬ê°ë„ ('error', 'warning', 'critical' ë“±)
            **kwargs: ì¶”ê°€ ë°ì´í„°
        """
        # ë¡œê¹…
        if severity == "critical":
            self.log_critical(f"{error_type}: {message}")
        elif severity == "warning":
            self.log_warning(f"{error_type}: {message}")
        else:
            self.log_error(f"{error_type}: {message}")
        
        # ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸ - ì˜¤ë¥˜ ì¹´ìš´íŠ¸ ì¦ê°€
        self.metric_manager.update_metric(
            self.exchange_code,
            MetricKeys.ERROR_COUNT,
            1,
            op="increment",
            error_type=error_type,
            error_message=message,
            severity=severity,
            timestamp=time.time()
        )
        
        # ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸ - ë§ˆì§€ë§‰ ì˜¤ë¥˜ ì‹œê°„
        self.metric_manager.update_metric(
            self.exchange_code,
            MetricKeys.LAST_ERROR_TIME,
            time.time(),
            error_type=error_type
        )
        
        # í…”ë ˆê·¸ë¨ ì•Œë¦¼ ì „ì†¡ (ì‹¬ê°í•œ ì˜¤ë¥˜ë§Œ)
        if severity in ["error", "critical"]:
            # ê±°ë˜ì†Œ ì´ë¦„ í¬í•¨ ì˜¤ë¥˜ ë©”ì‹œì§€ ìƒì„±
            exchange_name = self.exchange_name_kr.replace('[', '').replace(']', '')
            error_message = f"ğŸš¨ {exchange_name} ì˜¤ë¥˜: {error_type} - {message}"
            
            # ì•Œë¦¼ ê´€ë¦¬ìë¥¼ í†µí•œ ì•Œë¦¼ ì „ì†¡
            notification_manager = get_notification_manager()
            await notification_manager.send_notification(
                message=error_message,
                notification_type=NotificationType.ERROR,
                source=f"event_handler_{self.exchange_code}",
                metadata={"error_type": error_type, "severity": severity}
            )

    def update_metrics(self, metric_name: str, value: float = 1.0, op: str = "increment", **kwargs) -> None:
        """
        ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸ - êµ¬ë… í´ë˜ìŠ¤ì—ì„œ í˜¸ì¶œí•˜ëŠ” ë©”ì„œë“œ
        
        Args:
            metric_name: ë©”íŠ¸ë¦­ ì´ë¦„
            value: ë©”íŠ¸ë¦­ ê°’
            op: ì—°ì‚°ì (increment, set, max, min)
            **kwargs: ì¶”ê°€ íŒŒë¼ë¯¸í„°
        """
        try:
            # ë©”íŠ¸ë¦­ ê´€ë¦¬ìë¥¼ í†µí•´ ì§€ì •ëœ ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
            self.metric_manager.update_metric(
                self.exchange_code,
                metric_name,
                value,
                op=op
            )
            
            # íƒœê·¸ê°€ ìˆëŠ” ê²½ìš° íƒœê·¸ë³„ ë©”íŠ¸ë¦­ë„ ì—…ë°ì´íŠ¸
            for tag_name, tag_value in kwargs.items():
                self.metric_manager.update_metric(
                    self.exchange_code,
                    f"{metric_name}_{tag_name}_{tag_value}",
                    value,
                    op=op
                )
                
        except Exception as e:
            # ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí•´ë„ ì£¼ìš” ë¡œì§ì— ì˜í–¥ì„ ì£¼ì§€ ì•Šë„ë¡ í•¨
            logger.error(f"ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜: {e}")
            pass  # ì—ëŸ¬ ë¬´ì‹œ
    
    def get_status(self) -> Dict[str, Any]:
        """
        ìƒíƒœ ì •ë³´ ì¡°íšŒ
        
        Returns:
            Dict: ìƒíƒœ ì •ë³´
        """
        # ê¸°ë³¸ ì •ë³´ë¡œ ë³´ê°•
        exchange_status = {
            "exchange_code": self.exchange_code,
            "exchange_name": self.exchange_name_kr,
            "connection_status": self.connection_status,
            "subscriptions": self.subscriptions,
            "is_shutting_down": self._is_shutting_down
        }
        
        return exchange_status
    
    def get_exchange_status(self) -> Dict[str, Any]:
        """
        ê±°ë˜ì†Œ ìƒíƒœ ì •ë³´ ì¡°íšŒ (ì¶•ì•½ ë²„ì „)
        
        Returns:
            Dict: ê±°ë˜ì†Œ ìƒíƒœ ì •ë³´
        """
        return {
            "exchange": self.exchange_name_kr,
            "code": self.exchange_code,
            "connection": self.connection_status,
            "subscribed_symbols": len(self.subscriptions["symbols"])
        }

    async def handle_connection_status(self, status: str, timestamp: float = None, **kwargs) -> None:
        """
        ì—°ê²° ìƒíƒœ ë³€ê²½ ì´ë²¤íŠ¸ ì²˜ë¦¬
        
        Args:
            status: ì—°ê²° ìƒíƒœ ("connected", "disconnected", "reconnecting")
            timestamp: ì´ë²¤íŠ¸ ë°œìƒ ì‹œê°„ (Noneì´ë©´ í˜„ì¬ ì‹œê°„)
            **kwargs: ì¶”ê°€ ë°ì´í„°
        """
        # ì¤‘ë³µ ìƒíƒœ ë³€ê²½ ì´ë²¤íŠ¸ í•„í„°ë§
        if status == self.connection_status:
            return
            
        # íƒ€ì„ìŠ¤íƒ¬í”„ ì„¤ì •
        if timestamp is None:
            timestamp = time.time()
        
        # ì´ì „ ì—°ê²° ìƒíƒœ ì €ì¥
        old_status = self.connection_status
        
        # í˜„ì¬ ì—°ê²° ìƒíƒœ ì—…ë°ì´íŠ¸ (ìš´ì˜ ë¡œì§ìš© ìƒíƒœ ì €ì¥)
        self.connection_status = status
        
        # ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸ (ëª¨ë‹ˆí„°ë§ ë° ë³´ê³ ìš© ìƒíƒœ ì €ì¥)
        self.metric_manager.update_metric(
            self.exchange_code,
            MetricKeys.CONNECTION_STATUS,
            status,
            old_status=old_status,
            timestamp=timestamp,
            message=kwargs.get('message', '')
        )
        
        # ìƒíƒœ ë³€ê²½ ì‹œê°„ ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
        self.metric_manager.update_metric(
            self.exchange_code,
            MetricKeys.LAST_STATE_CHANGE,
            timestamp
        )
        
        # ë¡œê·¸ ê¸°ë¡
        status_msg = kwargs.get('message', '')
        status_emoji = {
            'connected': 'ğŸŸ¢',
            'disconnected': 'ğŸ”´',
            'reconnecting': 'ğŸ”µ',
        }.get(status, '')
        
        # ì—°ê²° ìƒíƒœ ë³€ê²½ ë¡œê·¸
        if status_msg:
            self.log_info(f"{status_emoji} ì—°ê²° ìƒíƒœ ë³€ê²½: {old_status} â†’ {status} ({status_msg})")
        else:
            self.log_info(f"{status_emoji} ì—°ê²° ìƒíƒœ ë³€ê²½: {old_status} â†’ {status}")
        
        # ì‹¬ê°í•œ ìƒíƒœì¸ ê²½ìš° ì•Œë¦¼ ë©”ì‹œì§€ ì „ì†¡
        need_notification = False
        
        # ì—°ê²° ëŠê¹€: ì•Œë¦¼ í•„ìš”
        if old_status == "connected" and status == "disconnected":
            need_notification = True
            alert_message = f"ğŸ”´ {self.exchange_name_kr} ì—°ê²° ëŠê¹€"
        
        # ìµœì´ˆ ì—°ê²° ì„±ê³µ: ì•Œë¦¼ í•„ìš”
        elif old_status == "disconnected" and status == "connected" and kwargs.get('initial_connection', False):
            need_notification = True
            alert_message = f"ğŸŸ¢ {self.exchange_name_kr} ì—°ê²°ë¨"
        # ì¬ì—°ê²° ì„±ê³µ: ì•Œë¦¼ í•„ìš”
        elif old_status in ["disconnected", "reconnecting"] and status == "connected":
            need_notification = True
            alert_message = f"{self.exchange_name_kr} ì—°ê²° ë³µêµ¬ë¨"
            
        # í…”ë ˆê·¸ë¨ ì•Œë¦¼ ì „ì†¡
        if need_notification:
            asyncio.create_task(
                self.send_telegram_message("connection_status", alert_message)
            )
            
        # ì´ë²¤íŠ¸ ë°œí–‰ (ì‹œìŠ¤í…œ ì»´í¬ë„ŒíŠ¸ë“¤ì´ êµ¬ë…í•  ìˆ˜ ìˆìŒ)
        event_data = {
            "exchange_code": self.exchange_code,
            "status": status,
            "old_status": old_status,
            "timestamp": timestamp,
            "message": status_msg
        }
        await self.event_bus.publish(EventTypes.CONNECTION_STATUS, event_data)

    async def handle_subscription_status(self, status: str, symbols: list, **kwargs) -> None:
        """
        êµ¬ë… ìƒíƒœ ì´ë²¤íŠ¸ ì²˜ë¦¬
        
        Args:
            status: êµ¬ë… ìƒíƒœ ('subscribed', 'unsubscribed', 'error' ë“±)
            symbols: êµ¬ë… ì¤‘ì¸ ì‹¬ë³¼ ëª©ë¡
            **kwargs: ì¶”ê°€ ë°ì´í„°
        """
        # ë¡œê¹…
        self.log_info(f"êµ¬ë… ìƒíƒœ ë³€ê²½: {status}, ì‹¬ë³¼: {len(symbols)}ê°œ")
        
        # íƒ€ì„ìŠ¤íƒ¬í”„ ì„¤ì •
        timestamp = kwargs.get("timestamp", time.time())
        
        # ìƒíƒœ ì €ì¥ (ìš´ì˜ ë¡œì§ìš©)
        self.subscriptions = {
            "status": status,
            "symbols": symbols,
            "timestamp": timestamp
        }
        
        # ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸ (ëª¨ë‹ˆí„°ë§ ë° ë³´ê³ ìš©)
        status_value = 1 if status == 'subscribed' else 0
        self.metric_manager.update_metric(
            self.exchange_code,
            "subscription_status",
            status_value,
            status=status,
            symbols_count=len(symbols),
            timestamp=timestamp
        )
        
        # ì‹¬ë³¼ ìˆ˜ ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
        self.metric_manager.update_metric(
            self.exchange_code,
            "subscribed_symbols_count",
            len(symbols),
            timestamp=timestamp
        )
        
        # ì´ë²¤íŠ¸ ë²„ìŠ¤ ë°œí–‰
        event_data = {
            "exchange_code": self.exchange_code,
            "status": status,
            "symbols": symbols,
            "count": len(symbols),
            "timestamp": timestamp
        }
        await self.event_bus.publish(EventTypes.SUBSCRIPTION_STATUS, event_data)
    
    async def handle_message_received(self, message_type: str, size: int = 0, **kwargs) -> None:
        """
        ë©”ì‹œì§€ ìˆ˜ì‹  ì´ë²¤íŠ¸ ì²˜ë¦¬
        
        Args:
            message_type: ë©”ì‹œì§€ ìœ í˜• ('snapshot', 'delta', 'heartbeat' ë“±)
            size: ë©”ì‹œì§€ í¬ê¸° (ë°”ì´íŠ¸)
            **kwargs: ì¶”ê°€ ë°ì´í„°
        """
        # íƒ€ì„ìŠ¤íƒ¬í”„ ì„¤ì •
        timestamp = time.time()
        
        # ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
        # ì´ ë©”ì‹œì§€ ìˆ˜ ì¦ê°€
        self.metric_manager.update_metric(
            self.exchange_code,
            MetricKeys.MESSAGE_COUNT,
            1,
            op="increment",
            timestamp=timestamp
        )
        
        # ë©”ì‹œì§€ íƒ€ì…ë³„ ì¹´ìš´íŠ¸ ì—…ë°ì´íŠ¸
        if message_type == 'snapshot':
            self.metric_manager.update_metric(
                self.exchange_code,
                MetricKeys.SNAPSHOT_COUNT,
                1,
                op="increment",
                timestamp=timestamp
            )
        elif message_type == 'delta':
            self.metric_manager.update_metric(
                self.exchange_code,
                MetricKeys.DELTA_COUNT,
                1,
                op="increment",
                timestamp=timestamp
            )
        
        # ë§ˆì§€ë§‰ ë©”ì‹œì§€ ì‹œê°„ ì—…ë°ì´íŠ¸
        self.metric_manager.update_metric(
            self.exchange_code,
            MetricKeys.LAST_MESSAGE_TIME,
            timestamp
        )
        
        # ì´ë²¤íŠ¸ ë²„ìŠ¤ë¥¼ í†µí•œ ë©”ì‹œì§€ ì´ë²¤íŠ¸ ë°œí–‰
        event_data = {
            "exchange_code": self.exchange_code,
            "message_type": message_type,
            "size": size,
            "timestamp": timestamp
        }
        
        # ì¶”ê°€ ë°ì´í„° ë³‘í•©
        for key, value in kwargs.items():
            event_data[key] = value
            
        # í•„ìš”í•œ ê²½ìš° ì—¬ê¸°ì„œ ì´ë²¤íŠ¸ ë°œí–‰ êµ¬í˜„

    async def handle_data_event(self, event_type: str, symbol: str, data: Any, **kwargs) -> None:
        """
        ë°ì´í„° ì´ë²¤íŠ¸ ì²˜ë¦¬
        
        Args:
            event_type: ì´ë²¤íŠ¸ íƒ€ì… ('snapshot', 'delta' ë“±)
            symbol: ì‹¬ë³¼ëª…
            data: ì´ë²¤íŠ¸ ë°ì´í„°
            **kwargs: ì¶”ê°€ ë°ì´í„°
        """
        # íƒ€ì„ìŠ¤íƒ¬í”„ ì„¤ì •
        timestamp = kwargs.get("timestamp", time.time())
        
        # ì²˜ë¦¬ ì‹œê°„ ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸ (ì œê³µëœ ê²½ìš°)
        if "processing_time" in kwargs:
            processing_time = kwargs["processing_time"]
            self.metric_manager.update_metric(
                self.exchange_code,
                MetricKeys.PROCESSING_TIME,
                processing_time,
                symbol=symbol,
                event_type=event_type,
                timestamp=timestamp
            )
        
        # ì´ë²¤íŠ¸ ë²„ìŠ¤ ë°œí–‰
        event_data = {
            "exchange_code": self.exchange_code,
            "symbol": symbol,
            "data": data,
            "timestamp": timestamp
        }
        
        # ì¶”ê°€ ë°ì´í„° ë³‘í•©
        for key, value in kwargs.items():
            if key != "timestamp":  # timestampëŠ” ì´ë¯¸ ì²˜ë¦¬í•¨
                event_data[key] = value
        
        await self.event_bus.publish(event_type, event_data)

    def set_shutting_down(self) -> None:
        """
        í”„ë¡œê·¸ë¨ ì¢…ë£Œ ìƒíƒœ ì„¤ì •
        
        ì´ ë©”ì„œë“œëŠ” í”„ë¡œê·¸ë¨ì´ ì¢…ë£Œ ì¤‘ì„ì„ í‘œì‹œí•˜ì—¬ 
        ë¶ˆí•„ìš”í•œ ë¡œê¹…ì´ë‚˜ ì•Œë¦¼ì„ ë°©ì§€í•©ë‹ˆë‹¤.
        """
        self._is_shutting_down = True
        self.log_debug("ì¢…ë£Œ ìƒíƒœë¡œ ì„¤ì •ë¨")

    async def publish_system_event(self, event_type: str, **data) -> None:
        """
        ì‹œìŠ¤í…œ ì´ë²¤íŠ¸ ë°œí–‰
        
        Args:
            event_type: ì´ë²¤íŠ¸ íƒ€ì…
            **data: ì´ë²¤íŠ¸ ë°ì´í„°
        """
        try:
            # ê¸°ë³¸ ì´ë²¤íŠ¸ ë°ì´í„° ìƒì„±
            event_data = {
                "exchange_code": self.exchange_code,
                "timestamp": time.time()
            }
            
            # ì¶”ê°€ ë°ì´í„° ë³‘í•©
            if data:
                event_data.update(data)
            
            # ì´ë²¤íŠ¸ ë²„ìŠ¤ë¥¼ í†µí•´ ë°œí–‰
            if hasattr(self, 'event_bus') and self.event_bus:
                # ì´ë²¤íŠ¸ íƒ€ì… ë§¤í•‘
                bus_event_type = event_type
                
                # ë¬¸ìì—´ ê¸°ë°˜ ì´ë²¤íŠ¸ íƒ€ì…ì„ ì ì ˆí•œ EventTypes ìƒìˆ˜ë¡œ ë§¤í•‘
                if event_type == "SYSTEM_STARTUP" or event_type.lower() == "system_startup":
                    bus_event_type = EventTypes.SYSTEM_STARTUP
                elif event_type == "SYSTEM_SHUTDOWN" or event_type.lower() == "system_shutdown":
                    bus_event_type = EventTypes.SYSTEM_SHUTDOWN
                elif event_type == "CONNECTION_STATUS" or event_type.lower() == "connection_status":
                    bus_event_type = EventTypes.CONNECTION_STATUS
                elif event_type == "SUBSCRIPTION_STATUS" or event_type.lower() == "subscription_status":
                    bus_event_type = EventTypes.SUBSCRIPTION_STATUS
                elif event_type == "ERROR_EVENT" or event_type.lower() == "error_event":
                    bus_event_type = EventTypes.ERROR_EVENT
                    
                # ì´ë²¤íŠ¸ ë°œí–‰
                await self.event_bus.publish(bus_event_type, event_data)
            else:
                self.log_warning(f"ì´ë²¤íŠ¸ ë²„ìŠ¤ê°€ ì—†ì–´ ì´ë²¤íŠ¸ ë°œí–‰ ë¶ˆê°€: {event_type}")
                
        except Exception as e:
            self.log_error(f"ì‹œìŠ¤í…œ ì´ë²¤íŠ¸ ë°œí–‰ ì¤‘ ì˜¤ë¥˜: {str(e)}", exc_info=True)

    async def send_telegram_message(self, event_type: str, message: str):
        """
        í…”ë ˆê·¸ë¨ ì•Œë¦¼ ì „ì†¡ (notification_manager ì‚¬ìš©)
        
        Args:
            event_type: ì´ë²¤íŠ¸ ìœ í˜•
            message: ì „ì†¡í•  ë©”ì‹œì§€
        """
        # ì´ë²¤íŠ¸ ìœ í˜•ì— ë”°ë¥¸ ì•Œë¦¼ íƒ€ì… ì„¤ì •
        notification_type = NotificationType.INFO
        if "error" in event_type.lower():
            notification_type = NotificationType.ERROR
        elif "warning" in event_type.lower():
            notification_type = NotificationType.WARNING
        
        # ë©”ì‹œì§€ì— ê±°ë˜ì†Œ ì •ë³´ ì¶”ê°€
        if not message.startswith(f"[{self.exchange_code}]"):
            message = f"[{self.exchange_code}] {message}"
        
        # notification_managerë¥¼ í†µí•´ ë©”ì‹œì§€ ì „ì†¡
        try:
            notification_manager = get_notification_manager()
            await notification_manager.send_notification(
                message=message,
                notification_type=notification_type,
                source="ob_collector",
                key=f"{self.exchange_code}:{event_type}:{hash(message)}",
                metadata={"exchange_code": self.exchange_code}
            )
        except Exception as e:
            # ì‹¤íŒ¨ ì‹œ ë¡œê¹…ë§Œ ìˆ˜í–‰ (ì¤‘ìš” ì•Œë¦¼ì´ ëˆ„ë½ë˜ì§€ ì•Šë„ë¡)
            self.log_error(f"í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: {str(e)}")