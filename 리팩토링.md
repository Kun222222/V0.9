# 이벤트 발행 시스템 통합 리팩토링 계획

## 1. 현재 상황 분석

### 1.1 이벤트 발행 관련 메서드 현황

#### SystemEventManager
- `publish_system_event_sync(event_type: str, **data)`
- `publish_system_event(event_type: str, **data)`
- `record_metric(exchange_code: str, metric_name: str, **data)`
- `_update_metric(exchange_code: str, metric_name: str, count: int)`
- `handle_metric_update(exchange_code: str, metric_name: str, count: int)`
- `increment_message_count(exchange_code: str)`

#### BaseWebsocketConnector
- `publish_system_event(event_type: str, **data)`
- `publish_system_event_async(event_type: str, **data)`
- `_publish_connection_event(status: str)`
- `send_telegram_notification(event_type: str, message: str)`

#### BaseSubscription
- `publish_system_event(event_type: str, **data)`
- `publish_system_event_sync(event_type: str, **data)`
- `_publish_subscription_status_event(symbols: List[str], status: str)`
- `publish_event(symbol: str, data: Any, event_type: str)`

### 1.2 문제점
1. 동기/비동기 메서드 혼재
2. 유사한 기능의 메서드가 여러 클래스에 중복 구현
3. 이벤트 발행 방식이 일관되지 않음
4. 메트릭 업데이트와 이벤트 발행이 혼재

## 2. 개선 방향

### 2.1 핵심 원칙
1. 모든 이벤트 발행은 비동기로 통일
2. SystemEventManager를 통한 중앙 집중식 이벤트 관리
3. 명확한 책임 분리
4. 일관된 메서드 네이밍과 인터페이스

### 2.2 통합된 이벤트 타입
```python
EVENT_TYPES = {
    "CONNECTION_STATUS": "connection_status",
    "METRIC_UPDATE": "metric_update",
    "ERROR_EVENT": "error_event",
    "SUBSCRIPTION_STATUS": "subscription_status",
    "ORDERBOOK_UPDATE": "orderbook_update"
}
```

## 3. 리팩토링 계획

### 3.1 SystemEventManager 개선

#### 제거할 메서드
- `publish_system_event_sync`
- `_update_metric` (private 메서드를 update_metric으로 변경)
- `handle_metric_update` (중복 기능)

#### 새로운 메서드
```python
async def publish_event(self, event_type: str, **data) -> None:
    """모든 이벤트 발행을 처리하는 통합 메서드"""

async def publish_connection_event(self, exchange_code: str, status: str, **data) -> None:
    """연결 상태 이벤트 발행 전용 메서드"""

async def publish_error_event(self, exchange_code: str, error_type: str, message: str, severity: str = "error") -> None:
    """오류 이벤트 발행 전용 메서드"""

async def publish_subscription_event(self, exchange_code: str, symbols: List[str], status: str) -> None:
    """구독 상태 이벤트 발행 전용 메서드"""

async def publish_metric_event(self, exchange_code: str, metric_name: str, value: Any) -> None:
    """메트릭 업데이트 이벤트 발행 전용 메서드"""

async def update_metric(self, exchange_code: str, metric_name: str, value: Any) -> None:
    """메트릭 업데이트 통합 메서드"""
```

### 3.2 BaseWebsocketConnector 수정

#### 제거할 메서드
- `publish_system_event`
- `publish_system_event_async`
- `_publish_connection_event`

#### 새로운 메서드
```python
async def publish_event(self, event_type: str, **data) -> None:
    """SystemEventManager로 이벤트 발행을 위임하는 메서드"""

async def publish_connection_status(self, status: str) -> None:
    """연결 상태 변경 이벤트 발행"""

async def publish_error(self, error_type: str, message: str, severity: str = "error") -> None:
    """오류 이벤트 발행"""

async def send_notification(self, event_type: str, message: str) -> None:
    """알림 전송 (텔레그램 등)"""
```

### 3.3 BaseSubscription 수정

#### 제거할 메서드
- `publish_system_event`
- `publish_system_event_sync`
- `_publish_subscription_status_event`

#### 새로운 메서드
```python
async def publish_event(self, event_type: str, **data) -> None:
    """SystemEventManager로 이벤트 발행을 위임하는 메서드"""

async def publish_subscription_status(self, symbols: List[str], status: str) -> None:
    """구독 상태 이벤트 발행"""

async def publish_orderbook_event(self, symbol: str, data: Any, event_type: str) -> None:
    """오더북 이벤트 발행"""
```

### 3.4 구현 순서

1. **1단계: SystemEventManager 리팩토링**
   - 새로운 메서드 구현
   - 기존 동기 메서드 제거
   - 메트릭 관련 로직 정리

2. **2단계: BaseWebsocketConnector 수정**
   - 이벤트 발행 로직을 SystemEventManager로 위임
   - 연결 상태 관리 개선
   - 알림 시스템 통합

3. **3단계: BaseSubscription 수정**
   - 이벤트 발행 로직을 SystemEventManager로 위임
   - 구독 상태 관리 개선
   - 오더북 이벤트 처리 통합

4. **4단계: 거래소별 구현체 수정**
   - bithumb_s_sub.py
   - bybit_f_sub.py
   - bybit_s_sub.py
   - upbit_s_sub.py
   - 각 거래소별 커넥터 파일들

5. **5단계: OrderManager 수정**
   - 이벤트 처리 로직 통합
   - 상태 관리 개선

### 3.5 테스트 계획

1. **단위 테스트**
   - 각 새로운 메서드에 대한 테스트 케이스 작성
   - 이벤트 발행 순서 및 데이터 정확성 검증
   - 오류 처리 검증

2. **통합 테스트**
   - 전체 이벤트 흐름 테스트
   - 거래소별 특수 케이스 검증
   - 성능 테스트

3. **시스템 테스트**
   - 실제 환경에서의 동작 검증
   - 장시간 실행 테스트
   - 오류 복구 테스트

## 4. 주의사항

### 4.1 호환성
- 기존 이벤트 구독자들의 동작 보장
- 이벤트 데이터 구조 유지
- 기존 로깅 시스템과의 통합 유지

### 4.2 성능
- 이벤트 발행 지연 최소화
- 메모리 사용량 모니터링
- 동시성 처리 최적화

### 4.3 안정성
- 오류 처리 강화
- 재시도 메커니즘 구현
- 장애 복구 로직 개선

## 5. 향후 개선 사항

1. **모니터링 강화**
   - 이벤트 처리 성능 메트릭 추가
   - 상세한 로깅 시스템 구현
   - 실시간 모니터링 대시보드 구현

2. **확장성 개선**
   - 새로운 이벤트 타입 추가 용이성 확보
   - 구독자 관리 시스템 개선
   - 이벤트 필터링 기능 추가

3. **문서화**
   - API 문서 업데이트
   - 이벤트 스키마 문서화
   - 사용 예제 추가 

## 6. 현재까지 진행된 리팩토링 작업

### 6.1 완료된 작업

1. **SystemEventManager 리팩토링**
   - 중복 기능을 하는 메서드 통합
     - `publish_system_event`와 `publish_event` 통합
     - `set_current_exchange`와 `clear_current_exchange` 중복 제거
     - `handle_metric_update` 중복 제거
     - `record_metric` 메서드 정리
   - 명확한 이벤트 발행 인터페이스 구현
   - 이벤트 타입 상수 정의 및 활용

2. **BaseSubscription 수정**
   - 기존 `publish_event` 메서드를 `publish_orderbook_event`로 변경
   - 새로운 비동기 `publish_event` 메서드 추가
   - 동기식 `publish_event_sync` 메서드 추가
   - 호환성을 위한 `publish_system_event_sync`, `publish_system_event` 메서드 유지

3. **거래소별 구현체 수정**
   - bybit_s_sub.py, bithumb_s_sub.py, bybit_f_sub.py, upbit_s_sub.py 각 파일에서
     - `publish_event` 호출을 `publish_orderbook_event`로 변경
     - 오류 이벤트 발행 방식 통일

### 6.2 근본적 해결 방법의 중요성

리팩토링 과정에서 가장 중요한 원칙은 **근본적 해결 방법**을 적용하는 것입니다. 이는 다음과 같은 이유에서 중요합니다:

1. **지속 가능성**: 임시 방편이나 단순 수정은 나중에 더 큰 문제를 야기할 수 있습니다. 근본적인 해결책은 장기적으로 지속 가능한 코드를 만듭니다.

2. **일관성**: 코드베이스 전체에 일관된 패턴과 규칙을 적용하면 유지보수가 쉬워지고 버그 발생 가능성이 줄어듭니다.

3. **확장성**: 근본적인 구조 개선은 미래에 새로운 기능을 추가하거나 시스템을 확장할 때 더 용이합니다.

4. **디버깅 용이성**: 잘 설계된 시스템은 문제가 발생했을 때 원인을 추적하고 해결하기 쉽습니다.

현재까지의 리팩토링은 단순히 오류를 해결하는 데 그치지 않고, 이벤트 발행 시스템의 구조적 문제를 해결하는 데 중점을 두었습니다. 이러한 접근법을 통해 코드의 품질과, 유지보수성, 확장성이 크게 향상되었습니다.

### 6.3 다음 단계 계획

1. **남은 구독 클래스 리팩토링**
   - `BaseWebsocketConnector`와 파생 클래스의 이벤트 발행 메서드 정리
   - 추가 거래소 구현체에 일관된 패턴 적용

2. **테스트 강화**
   - 리팩토링된 코드에 대한 단위 테스트 추가
   - 기존 기능이 동일하게 동작하는지 확인

3. **성능 최적화**
   - 이벤트 발행 및 처리 성능 측정
   - 비동기 작업 최적화 